//
// The Commit Protocol takes as input a set of produce requests and commits the
// associated batches. This involves (1) building and uploading the batch data
// to cloud storage, (2) committing metadata about the object into each
// partition targetted by the produce requests and (3) acknowledging each client
// with the final committed offset.
//

// An L0d object stores payload data from produced batches without offsets.
// In the model, the position of an entry in an L0d object is used as its
// identifer in placeholder batches. The values in the L0d object are unique
// batch identifiers generated by the client. They represent the "content" of
// the batch, and must not be used by the model except for validation.
type L0d_object = seq[int];

machine CommitProtocol {
  var storage: Storage;
  var requests: seq[produce_request];

  // the L0d object that will be built and uploaded
  var object: L0d_object;
  var object_id: int;

  // mapping from offset in object to source request
  var object_to_request: seq[int];
  // mapping from append request to offset of data in object
  var append_to_object: map[int, int];

  // holds the next request id
  var request_id: int;

  start state Init {
    entry (input: (storage: Storage, requests: seq[produce_request])) {
      storage = input.storage;
      requests = input.requests;
      goto Commit;
    }
  }

  state Commit {
    entry {
      build_L0d();
      upload_L0d();
      append_placeholders();
    }

    // Respond to the produce request with the committed offset.
    on append_response_event do (response: append_response) {
      var offset: int;
      var request: produce_request;

      // map the partition append response back the original produce request
      offset = object_to_request[append_to_object[response.request_id]];
      request = requests[offset];

      send request.source, produce_response_event, (
        request_id = request.request_id,
        offset = response.offset);
    }
  }

  // Build the L0d object from the input produce requests. Batches in the L0d
  // object may have any ordering as long as the object_to_request mapping
  // maintains the property that for each offset in the object, the value of
  // object_to_request[offset] is the offset of the source request.
  fun build_L0d() {
    var offset: int;
    var request: produce_request;
    while (offset < sizeof(requests)) {
      object += (sizeof(object), requests[offset].batch_id);
      object_to_request += (sizeof(object_to_request), offset);
      offset = offset + 1;
    }
  }

  // Upload the L0d object. For convenience and without loss of generality, the
  // storage service, rather than the broker, generates a globally unique
  // identifier for the object.
  fun upload_L0d() {
    send storage, put_request_event, (
      source = this,
      request_id = request_id,
      object = object);

    receive {
      case put_response_event: (response: put_response) {
        assert response.request_id == request_id;
        object_id = response.object_id;
      }
    }

    request_id = request_id + 1;
  }

  // Append placeholder batches to every partition associated with data
  // contained in the L0d object. The append_to_request index maps append
  // requests to the request's source batch in the L0d object.
  fun append_placeholders() {
    var offset: int;
    var request: produce_request;

    while (offset < sizeof(object)) {
      append_to_object[request_id] = offset;
      request = requests[object_to_request[offset]];

      send request.partition, append_request_event, (
        source = this,
        request_id = request_id,
        batch = (L0d_object_id = object_id, L0d_offset = offset));

      request_id = request_id + 1;
      offset = offset + 1;
    }
  }
}
