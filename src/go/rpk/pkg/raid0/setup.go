// Copyright 2024 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

package raid0

import (
	"context"
	"embed"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"

	"github.com/spf13/afero"
	"go.uber.org/zap"

	"github.com/redpanda-data/redpanda/src/go/rpk/pkg/raid0/internal/shelltool"
)

var (
	ErrRAIDAlreadySetup = errors.New("RAID 0 seems to be already setup")
	ErrNotEnoughDevices = errors.New("at least 2 disk devices are required to create RAID device")
)

//go:embed systemd/var-lib-redpanda.mount
var mountUnitTpl embed.FS

// RedpandaRAID represents a disk array for Redpanda's data.
type RedpandaRAID struct {
	raidOpts
	l         *zap.SugaredLogger
	fs        afero.Fs
	mountUnit string
}

// NewRedpandaRAID creates a new instance of a RedpandaRAID type.
func NewRedpandaRAID(fs afero.Fs, l *zap.Logger, opts ...RAIDOpt) *RedpandaRAID {
	// default options
	options := raidOpts{
		devicePath:   "/dev/md0",
		mountPath:    "/var/lib/redpanda",
		blockSizeB:   4096,
		chunkSizeKiB: 16,
		mountOnBoot:  true,
		mountOptions: "defaults,noatime,nodiratime",
	}

	// overwrite defaults with caller provided values.
	for _, opt := range opts {
		opt(&options)
	}

	return &RedpandaRAID{
		l:        l.Sugar(),
		fs:       fs,
		raidOpts: options,
	}
}

// Setup creates a RAID 0 device, formats it using XFS and mounts it in the provided
// mount path.
func (rr *RedpandaRAID) Setup(ctx context.Context) error {
	if len(rr.memberDevicePaths) <= 1 {
		return ErrNotEnoughDevices
	}

	// lock any goroutines to the same OS thread to ensure that Pdeathsig
	// is never sent incorrectly: https://github.com/golang/go/issues/27505
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	systemdEscape, err := shelltool.SystemdEscape(rr.mountPath).Path().Suffix("mount").Build(ctx)
	if err != nil {
		return err
	}

	systemdUnitName, err := systemdEscape.Output()
	if err != nil {
		return fmt.Errorf("%q: %w", systemdEscape.String(), err)
	}

	rr.mountUnit = strings.TrimSpace(string(systemdUnitName))
	unitPath := path.Join("/etc/systemd/system", rr.mountUnit)
	if _, err := rr.fs.Stat(unitPath); errors.Is(err, fs.ErrNotExist) {
		rr.l.Debugf("systemd mount unit does not exist at %s: %w", unitPath, err)
	} else {
		return ErrRAIDAlreadySetup
	}

	rr.l.Infof("Creating RAID %q device at %q using [%s]...", "0", rr.devicePath, rr.memberDevicePaths)

	if err := rr.prepare(ctx); err != nil {
		return fmt.Errorf("preparing individual disk devices: %w", err)
	}

	udevadmSettle, err := shelltool.UdevadmSettle().Build(ctx)
	if err != nil {
		return fmt.Errorf("%q: %w", udevadmSettle.String(), err)
	}

	rr.l.Debugf("running %q...", udevadmSettle.String())
	if out, err := udevadmSettle.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	rr.l.Debugf("creating RAID device...")
	if err := rr.create(ctx); err != nil {
		return fmt.Errorf("creating RAID device: %w", err)
	}
	rr.l.Debugf("RAID device created at %q", rr.devicePath)

	udevadmSettle, err = shelltool.UdevadmSettle().Build(ctx)
	if err != nil {
		return fmt.Errorf("%q: %w", udevadmSettle.String(), err)
	}

	rr.l.Debugf("running %q...", udevadmSettle.String())
	if out, err := udevadmSettle.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	rr.l.Debugf("formatting RAID device using XFS...")
	if err := rr.format(ctx); err != nil {
		return fmt.Errorf("XFS formatting RAID disk: %w", err)
	}

	// Run udevadm settle since rr.mount() will be attempting to discover the
	// RAID device UUID generated by rr.format().
	udevadmSettle, err = shelltool.UdevadmSettle().Build(ctx)
	if err != nil {
		return fmt.Errorf("%q: %w", udevadmSettle.String(), err)
	}

	rr.l.Debugf("running %q...", udevadmSettle.String())
	if out, err := udevadmSettle.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	rr.l.Debugf("mounting RAID device...")
	if err := rr.mount(ctx); err != nil {
		return fmt.Errorf("mounting RAID disk: %w", err)
	}
	rr.l.Debugf("RAID device mounted at %q", rr.mountPath)

	return nil
}

func (rr *RedpandaRAID) Check() error { return nil }

// prepare prepares RAID members by discarding blocks and removing all previous
// filesystem signatures from all the individual disk devices.
func (rr *RedpandaRAID) prepare(ctx context.Context) error {
	for _, dpath := range rr.memberDevicePaths {
		dname := filepath.Base(dpath)
		discardValue, err := afero.ReadFile(rr.fs, fmt.Sprintf("/sys/block/%s/queue/discard_granularity", dname))
		if err != nil {
			if strings.TrimSpace(string(discardValue)) != "0" {
				blockDiscard, err := shelltool.BlockDiscard(dpath).Build(ctx)
				if err != nil {
					rr.l.Debugf("running %q...", blockDiscard.String())
					if out, err := blockDiscard.CombinedOutput(); err != nil {
						rr.l.Warnf("%s: %w", string(out), err)
					}
				}
			} else {
				rr.l.Warnf("skipping blkdiscard on %q: discard_granularity value is %q", dpath, discardValue)
			}
		} else {
			rr.l.Warnf("skipping blkdiscard on %q: %s", dpath, err)
		}

		wipeFS, err := shelltool.WipeFS(dpath).All().Build(ctx)
		if err != nil {
			return fmt.Errorf("preparing wipefs command: %w", err)
		}

		rr.l.Debugf("running %q...", wipeFS.String())
		if out, err := wipeFS.CombinedOutput(); err != nil {
			return fmt.Errorf("%s: %w", string(out), err)
		}
	}

	return nil
}

// create invokes mdadm(8) to create a RAIDO device and removes all previous filesystem
// signatures from the RAID0 device.
func (rr *RedpandaRAID) create(ctx context.Context) error {
	mdadmCreate, err := shelltool.MdadmCreate(rr.devicePath).
		Verbose().
		Force().
		Run().
		// So the RAID is not re-assembled as foreign, after host migrations in
		// cloud environments.
		HomeHost("any").
		Level("0").
		ChunkSize(int(rr.chunkSizeKiB)).
		DeviceNumber(len(rr.memberDevicePaths)).
		Devices(rr.memberDevicePaths...).
		Build(ctx)
	if err != nil {
		return err
	}

	rr.l.Debugf("running %q...", mdadmCreate.String())
	if out, err := mdadmCreate.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	// since wipefs -a on individual disks does not clear potential previous signatures
	// present on the RAID device.
	wipeFS, err := shelltool.WipeFS(rr.devicePath).All().Build(ctx)
	if err != nil {
		return err
	}

	rr.l.Debugf("running %q...", wipeFS.String())
	if out, err := wipeFS.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	rr.l.Debugf("updating mdadm.conf...")
	if err := rr.updateMDADMConf(ctx); err != nil {
		return fmt.Errorf("updating mdadm.conf file: %w", err)
	}

	// Updates initramfs' mdadm.conf, to make sure the RAID device can be
	// correctly re-assembled at booting time.
	rr.l.Debugf("updating initramfs...")
	if err := rr.updateInitRAMFS(ctx); err != nil {
		return fmt.Errorf("updating initramfs: %w", err)
	}

	return nil
}

// format runs mkfs.xfs on the RAID device, as quick as possible.
func (rr *RedpandaRAID) format(ctx context.Context) error {
	makeXFS, err := shelltool.MakeXFS(rr.devicePath).
		BlockSize(rr.blockSizeB).
		NoDiscard().
		Build(ctx)
	if err != nil {
		return err
	}

	rr.l.Debugf("running %q...", makeXFS.String())
	if out, err := makeXFS.CombinedOutput(); err != nil {
		return fmt.Errorf("%q: %w: %s", makeXFS.String(), err, string(out))
	}

	return nil
}

func (rr *RedpandaRAID) mount(ctx context.Context) error {
	blockID, err := shelltool.BlockID(rr.devicePath).
		MatchTag("UUID").
		OutputFormat("value").Build(ctx)
	if err != nil {
		return err
	}

	rr.l.Debugf("running %q...", blockID.String())
	output, err := blockID.Output()
	if err != nil {
		return fmt.Errorf("%q: %w", blockID.String(), err)
	}

	uuid := strings.TrimSpace(string(output))

	tpl, err := template.ParseFS(mountUnitTpl, "systemd/var-lib-redpanda.mount")
	if err != nil {
		return fmt.Errorf("parsing systemd unit template: %w", err)
	}

	unitFilePath := fmt.Sprintf("/etc/systemd/system/%s", rr.mountUnit)
	unitFile, err := rr.fs.OpenFile(unitFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o644)
	if err != nil {
		return fmt.Errorf("creating systemd mount unit: %w", err)
	}
	defer unitFile.Close()

	err = tpl.Execute(unitFile, map[string]interface{}{
		"Before":       "local-fs.target redpanda.service",
		"DiskUUID":     fmt.Sprintf("/dev/disk/by-uuid/%s", uuid),
		"MountPath":    rr.mountPath,
		"MountOptions": rr.mountOptions,
		"After":        "", // for future usage
		"Wants":        "", // for future usage
	})
	if err != nil {
		return fmt.Errorf("rendering systemd mount unit: %w", err)
	}

	systemctlDaemonReload, err := shelltool.SystemCTL().DaemonReload().Build(ctx)
	if err != nil {
		return err
	}

	rr.l.Debugf("running %q...", systemctlDaemonReload.String())
	if out, err := systemctlDaemonReload.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	systemctlEnable, err := shelltool.SystemCTL().
		Enable().
		Unit(rr.mountUnit).
		Build(ctx)
	if err != nil {
		return err
	}

	if rr.mountOnBoot {
		rr.l.Debugf("running %q...", systemctlEnable.String())
		if out, err := systemctlEnable.CombinedOutput(); err != nil {
			return fmt.Errorf("%s: %w", string(out), err)
		}
	}

	systemctlStart, err := shelltool.SystemCTL().
		Start().
		Unit(rr.mountUnit).
		Build(ctx)
	if err != nil {
		return err
	}

	rr.l.Debugf("running %q...", systemctlStart.String())
	if out, err := systemctlStart.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	return nil
}

// updateInitRAMFS updates the initramfs image with the new mdadm.conf file,
// so the RAID is correctly re-assembled on machine reboots.
func (rr *RedpandaRAID) updateInitRAMFS(ctx context.Context) error {
	updateInitRAMFS, err := shelltool.InitRAMFS().Update().Build(ctx)
	if err != nil {
		return err
	}

	if out, err := updateInitRAMFS.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}

	return nil
}

// updateMDADMConf updates mdadm.conf with RAID details returned by /proc/mdstat.
func (rr *RedpandaRAID) updateMDADMConf(ctx context.Context) error {
	mdadmDetail, err := shelltool.MdadmDetail().Scan().Build(ctx)
	if err != nil {
		return err
	}

	raidDetails, err := mdadmDetail.Output()
	if err != nil {
		return fmt.Errorf("%q: %w", mdadmDetail.String(), err)
	}

	f, err := rr.fs.OpenFile("/etc/mdadm/mdadm.conf", os.O_APPEND|os.O_WRONLY, 0o644)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := f.Write(raidDetails); err != nil {
		return err
	}

	return nil
}

// MountUnitName returns the systemd mount unit name configured after [Setup]
// finishes successfully.
func (rr *RedpandaRAID) MountUnitName() string {
	return rr.mountUnit
}
